\section{Implementation (code)}

    \subsection{Basic correctness}

        \begin{frame}[fragile]
            %% João Pizani wants to present this :)
            \frametitle{Source}

            Source types:
            \ExecuteMetaData[agda/tex/Source.tex]{tys}

            Source terms (snippet):
            \ExecuteMetaData[agda/tex/Source.tex]{src}

            Denotational semantics (snippet):
            \ExecuteMetaData[agda/tex/Source.tex]{eval}
\end{frame}

        \begin{frame}[fragile]
            \frametitle{Bytecode}
            %% João Pizani wants to present this :)

            Typed stack:
            \ExecuteMetaData[agda/tex/Bytecode.tex]{stacktype}
            \ExecuteMetaData[agda/tex/Bytecode.tex]{stack}

            Typed bytecode (snippet):
            \ExecuteMetaData[agda/tex/Bytecode.tex]{bytecode}
\end{frame}

        \begin{frame}
            \frametitle{Compiler correctness}
            %% João Pizani wants to present this :)
            % compile : ∀ {σ z s} → Src σ z → Bytecode s (replicate z σ ++ s)
            % compile (vₛ x)                  = PUSH x
            % compile (e₁ +ₛ e₂)              = compile e₂ ⟫ compile e₁ ⟫ ADD
            % compile ...                     = ...
            %
            % correct : {σ : Tyₛ} {z : Sizeₛ} (e : Src σ z)
            %         → exec (compile e) ≡ ⟦ e ⟧
        \end{frame}


    \subsection{Lifting to sharing setting}
        \begin{frame}
            \frametitle{Tree fixpoints}
            %% Wout presents this? :)
            % data Tree (r : Set -> Set) : Set where
            %   In (r (Tree r))

            % data HTree (r : StackType -> StackType -> Set) : (ixp : StackType) -> (ixq : StackType) -> Set where
            %   HTreeIn (r (HTree r)) ixp ixq : HTree r ixp ixq
        \end{frame}

        \begin{frame}
            \frametitle{Bytecode Tree Representation}
            %% Wout presents this? :)
            % data Bytecode : StackType → StackType → Set where
            %   PUSH : ∀ {σ s}  → (x : ⁅ σ ⁆) → Bytecode s (σ ∷ s)
            %   ADD  : ∀ {s}    → Bytecode (ℕₛ ∷ ℕₛ ∷ s) (ℕₛ ∷ s)
            % 
            % data BytecodeF (r : StackType -> StackType -> Set) : (StackType -> StackType -> Set
            %   PUSH' : ∀ {α s}  → (x : ⁅ α ⁆) → BytecodeF r s (α ∷ s)
            %   ADD'  : ∀ {s}    → BytecodeF r (ℕₛ ∷ ℕₛ ∷ s) (ℕₛ ∷ s)
            %
            % `Bytecode` is isomorphic to `HTree BytecodeF`:
            %   We have: fromGraph . toGraph == id
            %   But:     toGraph . fromGraph == id
        \end{frame}
                
        \begin{frame}
            \frametitle{Correctness on Trees}
            %% Wout presents this? :)
            % compileT compiles to HTree representation
            % execT executes HTree represented Bytecode
            %
            % correctT : ∀ {σ z s'} → (e : Src σ z) 
            %          → execT (compileT e) ≡ ⟦ e ⟧
            % 
            % The proof for `correctT` can be trivially lifted from `correct`,
            % because Bytecode is structurally the same as HTree BytecodeF
        \end{frame}

        \begin{frame}
            \frametitle{Graphs}
            %% Wout presents this? :)
            % Sample code from page 9, showing let/var
            %
            % data HGraph .. : ... -> Set where ...
            %
            % Additional constructors to represent shared subtrees
            %
            % `Bytecode` is not exactly isomorphic to `HGraph BytecodeF`:
            %   We have: fromGraph . toGraph == id
            %   But:     toGraph . fromGraph /= id
            
            % HGraph -> Bytecode -> HGraph loses sharing
        \end{frame}
         
         \begin{frame}
            \frametitle{Bytecode Graph Representation}
            %% Wout presents this? :)
            % compileG compiles to HGraph representation
            % execG executes HGraph represented Bytecode
            %
            % correctG : ∀ {σ z s'} → (e : Src σ z) 
            %          → execG (compileG e) ≡ ⟦ e ⟧
            % 
            % Using machinery, we get this proof automatically from `correctT`
        \end{frame}

