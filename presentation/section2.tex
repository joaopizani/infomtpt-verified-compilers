\section{Implementation (code)}

    \subsection{Basic correctness}

        \begin{frame}[fragile]
            %% João Pizani wants to present this :)
            \frametitle{Source}

            Source types:
            \ExecuteMetaData[agda/tex/Source.tex]{tys}

            Source terms (snippet):
            \ExecuteMetaData[agda/tex/Source.tex]{src}

            Denotational semantics (snippet):
            \ExecuteMetaData[agda/tex/Source.tex]{eval}
\end{frame}

        \begin{frame}[fragile]
            \frametitle{Bytecode}
            %% João Pizani wants to present this :)

            Typed stack:
            \ExecuteMetaData[agda/tex/Bytecode.tex]{stacktype}
            \ExecuteMetaData[agda/tex/Bytecode.tex]{stack}

            Typed bytecode (snippet):
            \ExecuteMetaData[agda/tex/Bytecode.tex]{bytecode}
\end{frame}

        \begin{frame}[fragile]
            \frametitle{Compiler correctness}
            %% João Pizani wants to present this :)
            \ExecuteMetaData[agda/tex/Bytecode.tex]{compile}
            \begin{verbatim}
correct : {t : Tyₛ} {z : Sizeₛ} (e : Src t z)
        → exec (compile e) ≡ ⟦ e ⟧
            \end{verbatim}
\end{frame}


    \subsection{Lifting to sharing setting}
        \begin{frame}[fragile]
            \frametitle{Tree fixpoints}
            %% Wout presents this? :)
            Fixed Point for standard Functors
            \ExecuteMetaData[agda/tex/Bytecode.tex]{Tree}
            
            Fixed Point for indexed Functors
            \ExecuteMetaData[agda/tex/Bytecode.tex]{HTree}
\end{frame}

        \begin{frame}[fragile]
            \frametitle{Bytecode Tree Representation}
            %% Wout presents this? :)
            \ExecuteMetaData[agda/tex/Bytecode.tex]{bytecode}
            \ExecuteMetaData[agda/tex/Bytecode.tex]{bytecodeF}
            `Bytecode` is isomorphic to `HTree BytecodeF`:
            We have: `fromGraph . toGraph == id`
            And:     `toGraph . fromGraph == id`
\end{frame}
                
        \begin{frame}[fragile]
            \frametitle{Correctness on Trees}
            %% Wout presents this? :)
            \ExecuteMetaData[agda/tex/Bytecode.tex]{compileT}
            \ExecuteMetaData[agda/tex/Bytecode.tex]{execT}
            \begin{verbatim}
correctT : ∀ {t z s'} → (e : Src t z) 
         → execT (compileT e) ≡ ⟦ e ⟧
            \end{verbatim}
            The proof for `correctT` can be trivially lifted from `correct`,
            because `Bytecode` is structurally the same as `HTree BytecodeF`
\end{frame}

        \begin{frame}[fragile]
            \frametitle{Graphs}
            %% Wout presents this? :)
            % Sample code from page 9, showing let/var
            %
            \begin{verbatim}
data HGraph .. : ... -> Set where ...
            \end{verbatim}
            
            `HGraph` is like `HTree`, but with additional constructors to represent shared subtrees
            
            `Bytecode` is not exactly isomorphic to `HGraph BytecodeF`:
            We have: `fromGraph . toGraph == id`
            But:     `toGraph . fromGraph /= id`
            
            HGraph -> Bytecode -> HGraph loses sharing
\end{frame}
         
         \begin{frame}[fragile]
            \frametitle{Bytecode Graph Representation}
            %% Wout presents this? :)
            \ExecuteMetaData[agda/tex/Bytecode.tex]{compileG}
            \ExecuteMetaData[agda/tex/Bytecode.tex]{execG}
            \begin{verbatim}
correctG : ∀ {t z} → (e : Src t z) 
         → execG (compileG e) ≡ ⟦ e ⟧
            \end{verbatim}
            
            Using machinery, we get this proof automatically from `correctT`
\end{frame}

