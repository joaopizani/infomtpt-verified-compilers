\section{Implementation}

    \subsection{Source}
        % data Tyâ‚› : Set where
        %   â„•â‚› : Tyâ‚›
        %   ð”¹â‚› : Tyâ‚›
        %
        % data Src : (Ïƒ : Tyâ‚›) â†’ (z : Sizeâ‚›) â†’ Set where
        %   vâ‚›    : âˆ€ {Ïƒ} â†’ (v : â… Ïƒ â†) â†’ Src Ïƒ 1
        %   _+â‚›_  : (eâ‚ eâ‚‚ : Src â„•â‚› 1) â†’ Src â„•â‚› 1
        %  ...    : Src ...
        %
        % âŸ¦_âŸ§ : {Ïƒ : Tyâ‚›} {z : Sizeâ‚›} â†’ (e : Src Ïƒ z) â†’ Vec â… Ïƒ â† z
        % âŸ¦ vâ‚› v âŸ§                     = v
        % âŸ¦ eâ‚ +â‚› eâ‚‚ âŸ§                 = âŸ¦ eâ‚ âŸ§ + âŸ¦ eâ‚‚ âŸ§
        % ...                          = ...


    \subsection{Bytecode}
        % StackType : Set
        % StackType = List Tyâ‚›

        % data Stack : StackType â†’ Set where
        %   Îµ    : Stack []
        %  _â–½_  : âˆ€ {Ïƒ s'} â†’ â… Ïƒ â† â†’ Stack s' â†’ Stack (Ïƒ âˆ· s')

        % data Bytecode : StackType â†’ StackType â†’ Set where
        %   PUSH : âˆ€ {Ïƒ s}  â†’ (x : â… Ïƒ â†) â†’ Bytecode s (Ïƒ âˆ· s)
        %   ADD  : âˆ€ {s}    â†’ Bytecode (â„•â‚› âˆ· â„•â‚› âˆ· s) (â„•â‚› âˆ· s)
        %   ...  : ...

    \subsection{Compiler correctness}
        % compile : âˆ€ {Ïƒ z s} â†’ Src Ïƒ z â†’ Bytecode s (replicate z Ïƒ ++ s)
        % compile (vâ‚› x)                  = PUSH x
        % compile (eâ‚ +â‚› eâ‚‚)              = compile eâ‚‚ âŸ« compile eâ‚ âŸ« ADD
        % compile ...                     = ...
        %
        % correct : {Ïƒ : Tyâ‚›} {z : Sizeâ‚›} (e : Src Ïƒ z)
        %         â†’ exec (compile e) â‰¡ âŸ¦ e âŸ§


    \subsection{Tree fixpoints}
        % data Tree (r : Set -> Set) : Set where
        %   In (r (Tree r))

        % data HTree (r : StackType -> StackType -> Set) : (ixp : StackType) -> (ixq : StackType) -> Set where
        %   HTreeIn (r (HTree r)) ixp ixq : HTree r ixp ixq

    \subsection{Bytecode Tree Representation}
        % data Bytecode : StackType â†’ StackType â†’ Set where
        %   PUSH : âˆ€ {Ïƒ s}  â†’ (x : â… Ïƒ â†) â†’ Bytecode s (Ïƒ âˆ· s)
        %   ADD  : âˆ€ {s}    â†’ Bytecode (â„•â‚› âˆ· â„•â‚› âˆ· s) (â„•â‚› âˆ· s)
        % 
        % data BytecodeF (r : StackType -> StackType -> Set) : (StackType -> StackType -> Set
        %   PUSH' : âˆ€ {Î± s}  â†’ (x : â… Î± â†) â†’ BytecodeF r s (Î± âˆ· s)
        %   ADD'  : âˆ€ {s}    â†’ BytecodeF r (â„•â‚› âˆ· â„•â‚› âˆ· s) (â„•â‚› âˆ· s)
        %
        % `Bytecode` is isomorphic to `HTree BytecodeF`:
        %   We have: fromGraph . toGraph == id
        %   But:     toGraph . fromGraph == id
        

    \subsection{Correctness on Trees}
        % compileT compiles to HTree representation
        % execT executes HTree represented Bytecode
        %
        % correctT : âˆ€ {Ïƒ z s'} â†’ (e : Src Ïƒ z) 
        %          â†’ execT (compileT e) â‰¡ âŸ¦ e âŸ§
        % 
        % The proof for `correctT` can be trivially lifted from `correct`, because Bytecode is structurally the same as HTree BytecodeF

    \subsection{Graphs}

        % Sample code from page 9, showing let/var
        %
        % data HGraph .. : ... -> Set where ...
        %
        % Additional constructors to represent shared subtrees
        %
        % `Bytecode` is not exactly isomorphic to `HGraph BytecodeF`:
        %   We have: fromGraph . toGraph == id
        %   But:     toGraph . fromGraph /= id
        
        % HGraph -> Bytecode -> HGraph loses sharing
 
    \subsection{Bytecode Graph Representation}
        % compileG compiles to HGraph representation
        % execG executes HGraph represented Bytecode
        %
        % correctG : âˆ€ {Ïƒ z s'} â†’ (e : Src Ïƒ z) 
        %          â†’ execG (compileG e) â‰¡ âŸ¦ e âŸ§
        % 
        % Using machinery, we get this proof automatically from `correctT`
        
 
