\documentclass[a4paper]{article}

%% Standard packages
\usepackage{times}
\usepackage{a4}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{color}

%% Unicode support
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{autofe}


%% Agda
\usepackage{agda/agda}
\usepackage{catchfilebetweentags}


%% PDF metainformation
\usepackage{datetime}
\usepackage{ifpdf}
\ifpdf
\pdfinfo{
    /Author (Joao Paulo Pizani Flor, Wout Elsinghorst)
    /Title (Proving Compiler Correctness with Dependent Types)
    /Keywords (Agda, Dependently-typed programming, Compiler correctness, typed bytecode)
    /CreationDate (D:\pdfdate)
}
\fi


%% LaTeX meta-information
\title{Proving Compiler Correctness with Dependent Types}

\date{\today}
\author {
    João Paulo Pizani Flor \texttt{<j.p.pizaniflor@students.uu.nl>} \\
    \and Wout Elsinghorst \texttt{<w.l.elsinghorst@students.uu.nl>} \\
}



%% The document itself
\begin{document}
    \maketitle

    \section{Introduction}
    \label{sec:intro}
        In this report we describe our work for the final project of the master course
        "Theory of Programming and Types" at Utrecht University. Our research involves
        the question of compiler correctness, i.e, giving a \emph{specification} for
        a language (a semantics), and proving that a compiler for that language respects
        the given semantics.

        Concretely, our notion of correctness depends on two semantics, respectively for the source
        and object languages of the compiler. We define a denotational semantics (eval) for the source
        language, as well as an operational semantics (exec) for the target machine. Correctness
        states that evaluation is equal to compilation composed with execution.

        More specifically, we were interested in having \emph{machine-checked} proofs of correctness,
        i.e, proofs written in the language of an interactive proof assistant. Some initiatives in
        this direction are already being taken, most famously CompCert, a formally verified compiler
        for the C language, which had its proof written in the \emph{Coq} proof assistant.

        Our work (definitions and proofs) is, on the other hand, written in the
        \emph{Agda} programming language instead of emph{Coq} It also also differs from CompCert
        in that we use dependent types to make source and object languages (as well as the compiler)
        have some meta-theoretical properties (for example, type preservation) \emph{by construction},
        instead of proving them separately.

        Dependent types allow us to embed, as indices to the language definitions and in the type
        of the ``compile'' function, constraints which make these definitions correct.

        The rest of the report is organized as follows: on section \ref{sec:goals} we present the
        related papers which served as the basis for our research, and state precisely which were
        our contributions. On section \ref{sec:basic} we define the notion of correctness that we
        use, and present the definitions for our \emph{source} and \emph{object} languages,
        the compiler itself and the proof of correctness for that compiler. Section \emph{sec:lifiting}
        introduces a smarter version of the object language, in which sharing is captured, and a
        compiler which produces shared code. We then proceed to describe how,
        given a correctness proof for a ``naïve'' compiler, we can derive the correctness proof of 
        the smarter version.

    \section{Related work/Goals}
    \label{sec:goals}
        % Mention two papers we based our work on
        On researching the topic of compiler correctness in the context of dependent types, we first encountered
        the paper ``A type-correct, stack-safe, provably correct expression compiler in Epigram'' \cite{typed-stack-safe-compiler}.
        In this paper, a \emph{very simple} (but \emph{typed}) expression language is presented,
        along with a \emph{typed bytecode} definition. The correctness of this compiler is then formulated and proven.
        
        Both language definitions, the semantics for each of them, the compiler and its correctness proof
        were all written in Epigram, a dependently-typed programming language. Therefore,
        even though the authors admit that the paper carries no real novelty value related to compiler
        construction, we still felt this paper could serve well as the ``basis'' for our project, as they
        treat compilation of \emph{typed source} to \emph{typed bytecode}, and also use a dependently-typed
        implementation language.

        So our work started with trying to extend the source language from \cite{typed-stack-safe-compiler},
        and add constructs to it that made it more powerful. Then we came across the paper
        ``Proving Correctness of Compilers using Structured Graphs''\cite{compiler-correctness-structured-graphs}.
        In this paper, the author discusses the issue of \emph{sharing} of bytecode, that is, that
        some high-level language constructs (typically control flow related constructs,
        such as exception handling of conditional branching) map into low-level code which has
        \emph{shared blocks of code among different execution paths}.

        One way to compile these control flow constructs would be to extend the bytecode language with
        explicit jumps and labels, a solution which is often taken in ``real-world'' compilers,
        but which makes analyzing bytecode and proving compiler correctness much more complex.
        A simpler way to handle these situations is to just \emph{replicate} the shared code when
        compiling constructs which generate different execution paths.

        A compiler which works by using a jump-and-label-free bytecode and replicates shared code
        is easier to analyze, but the practically desirable behaviour is, off course, to represent
        the sharing. The main contribution of \cite{compiler-correctness-structured-graphs} is a
        systematic way in which a proof of correctness for a ``naïve'' (code-duplicating) compiler can
        be used to construct the correctness proof for a ``sharing optimized'' version of that compiler;
        a rather elegant approach.

        % Our wish to join the contributions of both papers
        The overall goal of our project was, therefore, to integrate the solutions given both in
        \cite{typed-stack-safe-compiler} and \cite{compiler-correctness-structured-graphs}.
        To acheive this goal we needed to make some adjustments to the definitions and proofs of
        the reference papers. These adjustments are what we perceive as our main contributions
        with this project:

        % What adaptations we did to each approach to help them work together:
        \begin{itemize}
            \item The solution in \cite{compiler-correctness-structured-graphs}
                used Haskell as implementation language (along with some proofs given in Coq).
                \begin{itemize}
                    \item We needed, therefore, to adapt definitions such as fixed point operators and generic
                        maps/folds to the \emph{total} setting of Agda.
                \end{itemize}

            % Make functors and proofs of the lifting approach indexed
            \item The example bytecode language used in \cite{compiler-correctness-structured-graphs}
                to illustrate the method is \emph{untyped}.
                \begin{itemize}
                    \item To make the proof derivation scheme work for \emph{typed} bytecode,
                        we needed to also adapt most of the generic data structures presented to become \emph{indexed}.
                \end{itemize}

            % Extension in the Src to reveal "sharing opportunities"
            \item The example control flow construct used in \cite{compiler-correctness-structured-graphs}
                to introduce sharing (exceptions) was also not immediately applicable to being
                modeled in a total setting.
                \begin{itemize}
                    \item Specially the way in which it was implemented (by using Higher-Order Abstract Syntax)
                        clashed with Agda's requirement of \emph{strict positivity} for datatype definitions.
                    \item We chose a simpler sharing-inducing extension to the language of
                        \cite{typed-stack-safe-compiler} (sequencing and conditional branching).
                        This extension is explained in more detail in section \ref{sec:basic}
                \end{itemize}

            %% Making the "method" given in paper [2] an ACTUAL function
        \end{itemize}
        


    \section{Basic correctness}
    \label{sec:basic}
        % Introduce compiler correctness in general (no models mentioned)

        % Talk about our model with sequencing and the "vector values"
        Our source language (\texttt{Src}) is based upon, and therefore very similar, to the one
        defined in \cite{typed-stack-safe-compiler}. It is a typed expression language, in which
        the types are naturals and booleans. There are no binding or application constructs
        in this language, therefore no arrow type constructor. First, we show the type language for
        Src:

        %% CODE: Ty_s

        When naming constructs of the languages which are our "object of study", we give
        subscripts to distinguish them from similarly named definitions in Agda (the \emph{metalanguage}).
        In the case of the source language, the names are subscripted by a small-case ``s''.

        %% CODE: Src

        The definition of \texttt{Src} makes clear what is the main difference between our source language
        and the used defined in \cite{typed-stack-safe-compiler}: we have an additional \textbf{sequencing}
        construct. Even though the datatype definition is increased by only one constructor,
        this change has several subtleties:

        \begin{itemize}  % TODO
            \item Uniformly-typed sequences
            \item No ``sequential'' values, no arithmetic over sequences
            \item This is enforced by making expressions have a \emph{size}
        \end{itemize}

        As important as defining the constraints on well-formed expressions is also defining
        a \emph{semantics} for \texttt{Src}. We follow the same idea as in \cite{typed-stack-safe-compiler}
        and provide a denotational semantics for \texttt{Src}, written as a function \texttt{eval}
        which maps terms of \texttt{Src} to values.

        %% CODE: eval

        Because of the sequencing construct, we chose our values to be \emph{vectors} of naturals or
        booleans. The usage of vectors as values matches the requirement we imposed that sequences
        of expressions have to be uniformly-typed. Also, the size of the vector resulting from
        evaluation matches the size of the \texttt{Src} expression.

        %% The type of EVAL states type preservation (citation of paper [1])

        A last interesting remark about \texttt{eval} is that the \emph{type signature of eval
            expresses type preservation}. This phenomenon, of having proven a meta-theoretical
        property ``for free'', is allowed by the use of dependent types on the definitions of the
        language and the evaluator. On a non-dependent setting, such a property would have to be
        proven separately, in an ``offline'' proof.

        %% Bytecode
        %% exec

        %% Correctness proof


    \section{Lifiting to shared setting}
    \label{sec:lifiting}
        % What is the sharing opportunity (diagram, just Src code example)
        % A different representation of Bytecode (graph) that could capture sharing
            % Give example of a "BytecodeG" term...
        % If we make Bytecode into functor, we can have different representations by
        % applying fixed-point-like operators
          % Htree, HGraph (iso, not iso really)

        % State the "lifting" theorems
            % Grand finale: correctG
           

    \section{Conclusions}
    \label{sec:conclusions}
        % Summarize contributions (again?)

        % Points where we got stuck (holes, postulates)
            % Some possibilities of attempts, if we had more time

        % Difficulties encountered along the way
            % Ideas of why they happened
                % Tool-related (Agda)
                % Domain-related (problem inherently hard)



    \bibliographystyle{plain}
    \bibliography{../references}

\end{document}
